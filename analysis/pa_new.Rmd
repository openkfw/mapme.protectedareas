---
title: "Portfolio Analysis of Protected Areas"
#subtitle: "with financial support by KfW"
abstract: 
author: "[Johannes Schielein](mailto:johannes.schielein@kfw.de), [Sven Bergtold](mailto:sven.bergtold@kfw.de)"
date: "`r format(Sys.time(), '%d. %B %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    
editor_options:
  chunk_output_type: console
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r source_files}

source(file = "~/shared/sven/WiWe/md_helper_fcts.R")
#toc_float: true

options(scipen = 999)

```


```{r load_data}

#load(file = "~/shared/sven/WiWe/md_data.RData")
load(file = "~/shared/sven/WiWe/storage/carbon_storage.rda")
load(file = "~/shared/sven/WiWe/storage/ecosystem_services.rda")
load(file = "~/shared/sven/WiWe/storage/teow_biomes_ecoregions.rda")
load(file = "~/shared/sven/WiWe/storage/habitat_species.rda")
load(file = "~/shared/sven/WiWe/storage/forest_polys.rda")
load(file = "~/shared/sven/WiWe/storage/biomass_wide.rda")

kfw_finance <- readr::read_csv(file = "~/shared/sven/WiWe/storage/mapme.protectedareas_kfw-finance_complete-2021-03-17.csv")

biomass_long <-   biomass_wide |>
  dplyr::inner_join(ecosystem_services |> sf::st_drop_geometry() |> dplyr::select(wdpa_id, iso3, donor, start_date, end_date), by = c("wdpaid" = "wdpa_id")) |>
  dplyr::select(wdpaid, iso3, donor, start_date, end_date, area_tot_km2, agb_tot_c_mg, bgb_tot_c_mg, gsoc_tot_c_mg) |>
  tidyr::pivot_longer(
    cols = c(agb_tot_c_mg, bgb_tot_c_mg, gsoc_tot_c_mg)
    , names_to = "carbon"
    , values_to = "value"
  )

biomass_long$carbon<-gsub("agb_tot_c_mg", "Soil Organic Carbon", biomass_long$carbon)
biomass_long$carbon<-gsub("bgb_tot_c_mg", "Below Ground Carbon", biomass_long$carbon)
biomass_long$carbon<-gsub("gsoc_tot_c_mg", "Above Ground Carbon", biomass_long$carbon)


```


## Introduction

Conservation finance is an important field in the KfW development bank with considerable investment into Protected Areas (short: PAs). The evaluation department, together with operational departments, tries to learn more about our conservation projects by using our project documentation as well as open geo-datasets to assess the relevance and effectiveness of supported areas. The main impact goals of our conservation financing efforts can be summarized under three broad topics: 

1. Conservation of biological diversity.
2. Mitigation of global climate change e.g by reducing deforestation.
3. Improvement of livelihoods of the local population that uses the natural resources.


### Financial support

Conservation finance has increased in importance for German development cooperation and considerably more financial resources had been spent since 2004. 


```{r financial_support}

# tmp01 <- ecosystem_services |>
#   sf::st_drop_geometry() |>
#   dplyr::select(pledged, start_date) |>
#   dplyr::mutate(
#     year = as.factor(lubridate::year(start_date))
#   ) |>
#   dplyr::group_by(year) |>
#   dplyr::summarise(fin_support = round(sum(as.numeric(pledged) / 10^6, na.rm = TRUE), 2))

tmp01 <- kfw_finance |>
  dplyr::mutate(
    year = as.factor(year)
  ) |>
  dplyr::group_by(year) |>
  dplyr::summarise(
    fin_support = round(sum(disbursement_total / 10^6, na.rm = TRUE), 2)
  ) |>
  dplyr::ungroup() |>
  dplyr::mutate(
    cum_fin_support = cumsum(fin_support)
  )

plot_e1 <- tmp01 |>
  echarts4r::e_charts(x = year) |>
  echarts4r::e_bar(serie = fin_support) |>
  echarts4r::e_legend(show = FALSE) |>
  echarts4r::e_title(text = "Financial support per year", subtext = "Mio. €") |>
  echarts4r::e_y_axis(
    splitNumber = 10
    , splitLine = list(lineStyle = list(color = "#000000", width = 1, type = "dashed", interval = 1))
    , axisLine = list(show = TRUE, lineStyle = list(color = "#000000"))
  ) |>
  echarts4r::e_tooltip() |>
  echarts4r::e_datazoom() |>
  echarts4r::e_group(group = "grp1")

plot_e2 <- tmp01 |>
  echarts4r::e_charts(x = year) |>
  echarts4r::e_line(serie = cum_fin_support) |>
  echarts4r::e_legend(show = FALSE) |>
  echarts4r::e_title(text = "Financial support per year (cumulative)", subtext = "Mio. €") |>
  echarts4r::e_y_axis(
    splitNumber = 10
    , splitLine = list(lineStyle = list(color = "#000000", width = 1, type = "dashed", interval = 1))
    , axisLine = list(show = TRUE, lineStyle = list(color = "#000000"))
  ) |>
  echarts4r::e_tooltip() |>
  echarts4r::e_datazoom(show = FALSE) |>
  echarts4r::e_group(group = "grp1") |>
  echarts4r::e_connect_group(group = "grp1")

#plot_e

echarts4r::e_arrange(plot_e1, plot_e2, rows = 1, cols = 2)

```

**Todo**: 

* We have to check the correct values for financial support / pledged / disbursed money. Possibly, the data has to be stored within the database.
* Add overview on projects by year. 

### Portfolio overview

We machted our portfolio with the *World Database on Protected Areas - WDPA* (IUCN) and used data from the multiple different open data-sources to make an assessment of our portfolio and evaluate the impacts of our projects. 

```{r, out.width = '100%'}

tmp03 <- ecosystem_services

tmp03$label_donor <-
  with(tmp03, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "Donor: ", donor, "</br>"
    #, "Carbon (tonnes): ", carbon, "</br>"
    , "</p>", sep = "")
  )

tmp03$label_at <-
  with(tmp03, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "Area Type: ", marine, "</br>"
    , "</p>", sep = "")
  )


tmp03$label_iucn <-
  with(tmp03, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "IUCN Category: ", iucn_factor, "</br>"
    , "</p>", sep = "")
  )


tmp03$label_status <-
  with(tmp03, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "Status: ", project_status, "</br>"
    , "Start: ", start_date, "</br>"
    , "End: ", end_date, "</br>"
    , "</p>", sep = "")
  )

# Create color palettes.
#c("#879900", "#519DC2", "#BDC0C2", "#005A8C", "#517667", "#BAC9C3", "#9D1B6A", "#EBCEE2", "#5B2B6F", "#DED5E2", "#C80538", "#5E7200"), "#FFFFFF"


pal_donor <- leaflet::colorFactor(
  palette = c("#FF0000", "#005A8C", "#5E7200") #rev(RColorBrewer::brewer.pal(4, "Set1")) #"RdBu" "Pastel1"
  #, domain = unique(tmp03$donor)
  , domain = unique(ecosystem_services$donor)
)

pal_at <- leaflet::colorFactor(
  palette = c("#005A8C", "#9D1B6A", "#879900", "#BDC0C2") #rev(RColorBrewer::brewer.pal(4, "Set1")) #"RdBu" "Pastel1"
  , domain = unique(tmp03$marine)
)

pal_iucn <- leaflet::colorFactor(
  palette = c("#BDC0C2", "#005A8C", "#517667", "#BAC9C3", "#9D1B6A", "#EBCEE2", "#5B2B6F", "#DED5E2", "#C80538", "#5E7200")
  , domain = unique(tmp03$iucn_factor)
)

pal_status <- leaflet::colorFactor(
  palette = c("#517667", "#FF0000", "#BDC0C2")
  , domain = unique(tmp03$project_status)
)

# Polygon data. 
tmp_polys <- forest_polys |>
  dplyr::inner_join(ecosystem_services |> sf::st_drop_geometry() |> dplyr::select(geographic, donor), by = c("id" = "geographic" ))

# Change active geometry column (--> https://cran.r-project.org/web/packages/sf/vignettes/sf6.html)
#plot(st_geometry(tmp_polys))
#st_geometry(tmp_polys) <- "geom_original"
#plot(st_geometry(tmp_polys))


tmp_polys <- tmp_polys[!sf::st_is_empty(tmp_polys),,drop=FALSE] 

tmp_polys <- tmp_polys |>
  sf::st_collection_extract()


map01 <- create_empty_leaflet(overlays = c("Donor", "Area Type", "IUCN", "Status", "Polygons")) |>
  leaflet::addTiles() |>
  leaflet::addCircles(
    data = tmp03
    , color = ~pal_donor(donor)
    , group = "Donor"
    , popup = ~label_donor
  ) |>
  leaflet::addCircles(
    data = tmp03
    , color = ~pal_at(marine)
    , group = "Area Type"
    , popup = ~label_at
  ) |>
  leaflet::addCircles(
    data = tmp03
    , color = ~pal_iucn(iucn_factor)
    , group = "IUCN"
    , popup = ~label_iucn
  ) |>
  leaflet::addCircles(
    data = tmp03
    , color = ~pal_status(project_status)
    , group = "Status"
    , popup = ~label_status
  ) |>
  # leaflet::addPolygons(
  #     data = tmp_polys[13:500,] # Bec. some polygons make trouble, I can't plot all of them.
  #   , color = ~pal_donor(donor)
  #   , opacity = 0.9
  #   , group = "Polygons"
  #   #, label = ~htmltools::htmlEscape(project_name)
  #   , weight = 1
  # ) |>
  leaflet.extras::addFullscreenControl() |>
  leaflet::addLegend(
    "bottomright"
    , pal = pal_donor
    , values = unique(tmp03$donor)
    , title = "Donor"
    , group = "Donor"
    , opacity = 1.0
  ) |>
  leaflet::addLegend(
    "bottomright"
    , pal = pal_at
    , values = unique(tmp03$marine)
    , title = "Area Type"
    , group = "Area Type"
    , opacity = 1.0
  ) |>
  leaflet::addLegend(
    position = "bottomright"
    , pal = pal_iucn
    , values = unique(tmp03$iucn_factor)
    , title = "IUCN"
    , group = "IUCN"
    , opacity = 1.0
  ) |>
  leaflet::addLegend(
    position = "bottomright"
    , pal = pal_status
    , values = unique(tmp03$project_status)
    , title = "Status"
    , group = "Status"
    , opacity = 1.0
  ) |>
  leaflet::hideGroup(
    group = c("Area Type", "IUCN", "Status", "Polygons")
  )


map01

# dt99 <- DT::datatable(
#   tmp_polys
# )
# 
# dt99

```

***

Our database currently comprises `r nrow(ecosystem_services)` PAs which are situated in `r length(unique(ecosystem_services$iso3))` different countries. The extent of the PAs protected by KfW or GIZ by area type, donor and country is depicted in the table below. 

```{r}

tmp01_a <- ecosystem_services |>
  sf::st_drop_geometry() |> 
  dplyr::group_by(iso3, donor, marine) |>
  #dplyr::count() |>
  dplyr::summarise(
    Count = dplyr::n()
    , `Area (total; sq.km)` = round(sum(area_m2, na.rm = TRUE) / 10^6, 2)
    , `Forest Area (sq.km)` = round(sum(forest_area, na.rm = TRUE) / 10^6, 4)
    , `Mangrove Area (sq.km)` = round(sum(mangrove_area, na.rm = TRUE) / 10^6, 4)
  ) |>
  dplyr::ungroup() |> # Without ungroup, the mutate across does not work.
  #dplyr::mutate(dplyr::across(1, tolower))
  janitor::adorn_totals(where = "row") 

tmp01_b <- ecosystem_services |>
  sf::st_drop_geometry() |> 
  dplyr::group_by(marine) |>
  #dplyr::count() |>
  dplyr::summarise(
    Count = dplyr::n()
    , `Area (total; sq.km)` = round(sum(area_m2, na.rm = TRUE) / 10^6, 2)
    , `Forest Area (sq.km)` = round(sum(forest_area, na.rm = TRUE) / 10^6, 4)
    , `Mangrove Area (sq.km)` = round(sum(mangrove_area, na.rm = TRUE) / 10^6, 4)
  ) |>
  dplyr::ungroup() #|> # Without ungroup, the mutate across does not work.
  #dplyr::mutate(dplyr::across(1, tolower))
  #janitor::adorn_totals(where = "row") 

tmp01_c <- ecosystem_services |>
  sf::st_drop_geometry() |> 
  dplyr::group_by(donor) |>
  #dplyr::count() |>
  dplyr::summarise(
    Count = dplyr::n()
    , `Area (total; sq.km)` = round(sum(area_m2, na.rm = TRUE) / 10^6, 2)
    , `Forest Area (sq.km)` = round(sum(forest_area, na.rm = TRUE) / 10^6, 4)
    , `Mangrove Area (sq.km)` = round(sum(mangrove_area, na.rm = TRUE) / 10^6, 4)
  ) |>
  dplyr::ungroup() #|> # Without ungroup, the mutate across does not work.
  #dplyr::mutate(dplyr::across(1, tolower))
  #janitor::adorn_totals(where = "row") 

tmp01 <- dplyr::bind_rows(tmp01_b, tmp01_c, tmp01_a) |>
  dplyr::select(iso3, donor, dplyr::everything()) |>
  dplyr::rename(
    Country = iso3
    , Donor = donor
    , `Area type` = marine
  )


  # dplyr::mutate(dplyr::across(where(is.character), tolower)) |>
  #   dplyr::mutate(
  #   Comment = c(
  #     "Maritime / coastal PAs."
  #     , "Mixed marine and terrestrial PAs."
  #     , ""
  #     , "No info on marine available."
  #   )
  # ) |>

dt01 <- DT::datatable(
  tmp01
  , height = "auto"
  , width = "auto"
  , extensions = c("Buttons") #"FixedColumns"
  , options = list(
      scrollX = TRUE
    , scrollY = TRUE
    , searchHighlight = TRUE
    , pageLength = 20 # nrow(tmp01)
    #, fixedColumns = list(leftColumns = 2)
    , dom = 'Bfrtip'
    , buttons = c("pageLength", 'csv', 'excel') 
    , lengthMenu = list(c(10, 25, 50, -1), c("10 rows", "25 rows", "50 rows", "all"))
    #, dom = "t"
    #, columnDefs = list(list(className = "dt-right", targets = 3))
   )
 ) |>
  #DT::formatRound(digits = 2, columns = c(3:4))
  DT::formatStyle(
      0
    , target = "row"
    , fontWeight = DT::styleEqual(nrow(tmp01), "bold")
  ) |>
  DT::formatStyle(
      3
    , target = "row"
    , fontWeight = DT::styleEqual(nrow(tmp01), "bold")
  ) 
#   DT::formatStyle(
#     2
#     , `border-right` = "solid 2px"
#   )

dt01

surface_km2 <- round(sum(ecosystem_services$area_m2, na.rm = TRUE)/(10^6), digits = 2)
```

The table respectively groups the data by 

* area type, 
* donor and 
* country (ISO3), donor and area type. 

The area types are labeled like the following: 

* marine: Maritime / coastal PAs.
* partial: Mixed marine and terrestrial PAs.
* terrestrial: No info on marine available.

As you can see, the total surface of protected areas covers round about `r round(surface_km2 / (10^6), digits = 2)` Mio. km^2^ which is about `r round(surface_km2/357581, digits=1)` times the size of Germany.


### Projects on the Time Line {.tabset}


#### Overall

```{r}

# tl01 <- ecosystem_services |>
#   sf::st_drop_geometry() 
# 
# starts <- data.frame(table(lubridate::year(tl01$start_date)))
# ends <- data.frame(table(lubridate::year(tl01$end_date)))
# 
# 
# tl_counts <- data.frame(
#   year = as.factor(1990:2022)
# )
# 
# 
# tl_counts <- tl_counts |>
#   dplyr::left_join(starts, by = c("year" = "Var1")) |>
#   dplyr::left_join(ends, by = c("year" = "Var1")) |>
#   janitor::clean_names() |>
#   dplyr::mutate(
#     starts_projs = ifelse(is.na(freq_x), 0, freq_x)
#     , ends_projs = ifelse(is.na(freq_y), 0, freq_y)
#     , net_projs = starts_projs - ends_projs
#     , run_projs = cumsum(net_projs)
#   )
# 
# tl_aream2 <- timeline_value(value = "area_m2") |>
#   dplyr::mutate(year = as.factor(year))
# 
# tl_counts <- tl_counts |>
#   dplyr::left_join(tl_aream2, by = c("year"))
# 
# tl_e1 <- tl_counts |>
#   dplyr::mutate(ends_projs = (-1)*ends_projs) |>
#   echarts4r::e_charts(x = year) |>
#   echarts4r::e_bar(serie = starts_projs, name = "started projects") |>
#   echarts4r::e_bar(serie = ends_projs, name = "ended projects") |>
#   echarts4r::e_tooltip(trigger = "axis") |>
#   echarts4r::e_color(
#     c("#879900", "#C80538"), "#FFFFFF"
#   ) |>
#   echarts4r::e_datazoom() |>
#   echarts4r::e_group(group = "tl_grp")
# 
# 
# #tl_e1
# 
# tl_e2 <- tl_counts |>
#   echarts4r::e_charts(x = year) |>
#   echarts4r::e_bar(serie = net_projs, name = "net started projects") |>
#   echarts4r::e_bar(serie = run_projs, name = "running projects") |>
#   echarts4r::e_line(serie = wert, y_index = 1, name = "Area (sq.km; axis on the right)") |>
#   echarts4r::e_tooltip(trigger = "axis") |>
#   echarts4r::e_color(
#     c("#005A8C", "#517667", "#9D1B6A"), "#FFFFFF"
#   ) |>
#   echarts4r::e_group(group = "tl_grp") |>
#   echarts4r::e_datazoom(show = FALSE) |>
#   echarts4r::e_connect_group(group = "tl_grp")
# 
# #tl_e2
# 
# tl_counts_e <- echarts4r::e_arrange(tl_e1, tl_e2, rows = 2, cols = 1)
# 
# tl_counts_e

res_e <- timeline_frame()

res_e


```

#### KfW

```{r}
res_e <- timeline_frame(donor_sel = "KfW")

res_e
```

#### GIZ

```{r}
res_e <- timeline_frame(donor_sel = "GIZ")

res_e
```

#### KfW/GIZ

```{r}
res_e <- timeline_frame(donor_sel = "KfW/GIZ")

res_e
```


##  Ecoregions and Biomes

Conservation planning needs careful consideration on how to allocate limited financial resources in order to preserve the most relevant, remaining natural landscapes. In order to put money to work where it is most urgently needed, targeted ares should be high in biodiversity and endemism, as well as ecosystem functionality (and the degree to which they are threatened). Therefore, we need to use an adequate conceptual model that characterizes different natural areas in terms of biodiversity and ecosystem functionality. This will allow us to see how our financial resources are allocated among distinctive biotas (*Is that a word?*) and if we have an overall bias towards specific ecosystems while other relevant areas slip our attention. 

To that end we utilize the *Terrestrial Ecoregions of the World (TEOW)* classification system from Olson et al..^[REF - Olson et al: https://academic.oup.com/bioscience/article/51/11/933/227116] The *TEOW* system is based on biogeographic knowledge from thousands of experts and designed with the purpose of conservation planning in mind. It differentiates between 867 ecoregions which are nested in 14 large biomes. Ecoregions are defined as *relatively large units of land containing a distinct assemblage of natural communities and species, with boundaries that approximate the original extent of natural communities prior to major land-use change* (Olson et al.). Each ecoregion is part of a terrestrial biome which is a major ecosystem division that shares a common climate, vegetation type (e.g. tundra or forest), soiltype and wildlife. 

### Structure of biomes and ecoregions

```{r}

tmp02_a <- data.frame(
  geographic = c(teow_biomes_ecoregions$biome_geographic, teow_biomes_ecoregions$ecoregion_geographic)
) |>
  dplyr::distinct() |>
  na.omit()

# Looking for supported area without biome info.
# sven01 <- ecosystem_services |>
#   sf::st_drop_geometry() |>
#   dplyr::left_join(teow_biomes_ecoregions, by = c("geographic" = "biome_geographic"))

tmp02 <- tmp02_a |>
  dplyr::left_join(ecosystem_services |> sf::st_drop_geometry() |> dplyr::select(geographic, donor, area_m2, forest_area, mangrove_area), by = c("geographic" = "geographic")) |>
  dplyr::left_join(teow_biomes_ecoregions |> dplyr::select(biome_geographic, biome_name, biome_area), by = c("geographic" = "biome_geographic")) |>
  dplyr::left_join(teow_biomes_ecoregions |> dplyr::select(ecoregion_geographic, ecoregion_name, ecoregion_area), by = c("geographic" = "ecoregion_geographic"))

sunburst_data <- tmp02 |>
  dplyr::ungroup() |>
  dplyr::group_by(biome_name, ecoregion_name) |>
  dplyr::summarise(
    #area = mean(area_m2, na.rm = TRUE)
    #, biome_area = mean(biome_area, na.rm = TRUE)
    #, 
    n = round(sum(ecoregion_area, na.rm = TRUE)/(10^6), digits = 2)
    #n = part_on_fl
  ) 

sunburst_ly <- sunburst_data |>
  count_to_sunburst(width = 800, height = 800) 

sunburst_ly
```

The chart above depicts biomes and ecoregions in a hierarchical manner. The value *n* represents the corresponding areas -- supported by KfW or GIZ -- measured in square kilometers. 


### Covered areas

The subsquent table lists all biomes and corresponding ecoregions of KfW or GIZ protected areas, and also their respective surface.


```{r}

tmp03 <- tmp02 |>
  dplyr::ungroup() |>
  dplyr::group_by(donor, biome_name, ecoregion_name) |>
  dplyr::summarise(
    #area = mean(area_m2, na.rm = TRUE)
    #, biome_area = mean(biome_area, na.rm = TRUE)
    #, 
    `Area (sq.km)` = round(sum(ecoregion_area, na.rm = TRUE) / 10^6 , digits = 2) 
    #n = part_on_fl
  ) 

dt02 <- DT::datatable(
  tmp03 |>
  dplyr::rename(
    Donor = donor
    , Biome = biome_name
    , Ecoregion = ecoregion_name
  )
  , height = "auto"
  , width = 800
  , extensions = c("Buttons", "RowGroup") #"FixedColumns",
  , options = list(
    scrollX = TRUE
    , scrollY = TRUE
    , searchHighlight = TRUE
    , pageLength = 20
    #, fixedColumns = list(leftColumns = 2)
    , dom = 'Bfrtip'
    , buttons = c("pageLength", 'csv', 'excel') 
    , lengthMenu = list(c(10, 25, 50, -1), c("10 rows", "25 rows", "50 rows", "all"))
    #, dom = "t"
    #, columnDefs = list(list(className = "dt-right", targets = 3))
    , rowGroup = list(dataSrc = c(1, 2))
   )
  , callback = DT::JS(
        "table.on('click', 'tr.dtrg-group', function () {",
        "  var rowsCollapse = $(this).nextUntil('.dtrg-group');",
        "  $(rowsCollapse).toggleClass('hidden');",
        "});",
        "table.one('init', () => $('#my_table .dtrg-group').trigger('click'))"
      )
  , selection = "none"
 ) 

dt02

```

***

<br>

On an aggregate level, KfW and GIZ PAs cover a large range of different biomes and ecoregions. 

```{r}

tmp04 <- tmp03 |>
  dplyr::group_by(donor) |>
  dplyr::summarise(
    count_biome = dplyr::n_distinct(biome_name)
    , count_ecoregion = dplyr::n_distinct(ecoregion_name)
    , `Area (sq.km)` = sum(`Area (sq.km)`, na.rm = TRUE)
  ) |>
  dplyr::rename(
    Donor = donor
    , `Count of biomes` = count_biome
    , `Count of ecoregions` = count_ecoregion
  )


dt03 <- DT::datatable(
  tmp04
)

dt03
```

***

### IUCN and Designation 

On a micro level, we have additional information on each geographic, like IUCN category or the designation of the areas. 

[IUCN protected area categories](https://en.wikipedia.org/wiki/IUCN_protected_area_categories) are categories used to classify protected areas in a system developed by the *International Union for Conservation of Nature* (IUCN). The categories are classified as follows: 


```{r}

iucn <- readxl::read_xlsx(path = "~/shared/sven/WiWe/IUCN.xlsx") |>
  dplyr::select(-Beschreibung) |>
  dplyr::rename(
    Category = Kategorie
    , Type = Bezeichnung
  )

dt_iucn <- DT::datatable(
  iucn
)

dt_iucn

```

The following table depicts in which categories the respective sponsors are engaged. 


```{r}

IUCN_01 <- ecosystem_services |>
  sf::st_drop_geometry() |>
  dplyr::select(donor, iucn_category) |>
  dplyr::group_by(donor, iucn_category) |>
  dplyr::summarise(Count = dplyr::n()) |>
  #dplyr::group_map(~janitor::adorn_totals(.x, where = "row"))
  dplyr::group_modify(~janitor::adorn_totals(.x, where = "row")) 
  

IUCN_dt <- DT::datatable(
  IUCN_01 
  , height = "auto"
  , width = 800
  , extensions = c("Buttons", "RowGroup") #"FixedColumns",
  , options = list(
    scrollX = TRUE
    , scrollY = TRUE
    , searchHighlight = TRUE
    , pageLength = 20
    #, fixedColumns = list(leftColumns = 2)
    , dom = 'Bfrtip'
    , buttons = c("pageLength", 'csv', 'excel') 
    , lengthMenu = list(c(10, 25, 50, -1), c("10 rows", "25 rows", "50 rows", "all"))
    #, dom = "t"
    #, columnDefs = list(list(className = "dt-right", targets = 3))
    , rowGroup = list(dataSrc = c(1))
   )
  , callback = DT::JS(
        "table.on('click', 'tr.dtrg-group', function () {",
        "  var rowsCollapse = $(this).nextUntil('.dtrg-group');",
        "  $(rowsCollapse).toggleClass('hidden');",
        "});",
        "table.one('init', () => $('#my_table .dtrg-group').trigger('click'))"
      )
  , selection = "none"
 ) 

IUCN_dt


```




```{r}
desig_01 <- ecosystem_services |>
  sf::st_drop_geometry() |>
  dplyr::select(donor, designation) |>
  dplyr::group_by(donor, designation) |>
  dplyr::count() |>
  dplyr::arrange(donor, desc(n)) |>
  dplyr::rename(
    Designation = designation
    , Count = n
  )

desig_DT <- DT::datatable(
  desig_01
    , height = "auto"
  , width = 800
  , extensions = c("Buttons", "RowGroup") #"FixedColumns",
  , options = list(
    scrollX = TRUE
    , scrollY = TRUE
    , searchHighlight = TRUE
    , pageLength = 20
    #, fixedColumns = list(leftColumns = 2)
    , dom = 'Bfrtip'
    , buttons = c("pageLength", 'csv', 'excel') 
    , lengthMenu = list(c(10, 25, 50, -1), c("10 rows", "25 rows", "50 rows", "all"))
    #, dom = "t"
    #, columnDefs = list(list(className = "dt-right", targets = 3))
    , rowGroup = list(dataSrc = c(1))
   )
  , callback = DT::JS(
        "table.on('click', 'tr.dtrg-group', function () {",
        "  var rowsCollapse = $(this).nextUntil('.dtrg-group');",
        "  $(rowsCollapse).toggleClass('hidden');",
        "});",
        "table.one('init', () => $('#my_table .dtrg-group').trigger('click'))"
      )
  , selection = "none"
 ) 


desig_DT


```







**Todo**: 

* Get biomes and ecoregions for all geographics in partnering countries, not only for KfW projects. 
* Check, why some supported areas (approx. 150) don't have data on biome or ecoregion. 



## Ecosystem Services

### Carbon Storage {.tabset}

Geodata can also tell us a bit about the relevance of conserving forests to mitigate global climate change. The following charts show, for example, estimations on how much carbon is stored in the soils as well as in the belowground and aboveground biomass inside supported protected areas. Conservation finance can help to keep this carbon in place that might be otherwise released to the atmosphere due to deforestation and forest degradation. 


The graphics and tables below gather data from the [Digital Observatory for Protected Areas](https://dopa.jrc.ec.europa.eu/dopa/documentation/en) on the following carbon indicators: 

* [Above-Ground Carbon Stock](https://dopa.jrc.ec.europa.eu/var/www/app/app/static/dopa/files/factsheets/en/DOPA%20Factsheet%20J2%20EN%20Above-Ground%20Carbon%20Stock.pdf)
* [Belowground Biomass Carbon Stock](https://dopa.jrc.ec.europa.eu/var/www/app/app/static/dopa/files/factsheets/en/DOPA%20Factsheet%20J3%20EN%20Below%20Ground%20Carbon.pdf)
* [Soil Organic Carbon](https://dopa.jrc.ec.europa.eu/var/www/app/app/static/dopa/files/factsheets/en/DOPA%20Factsheet%20J1%20EN%20Soil%20Carbon.pdf)


```{r}
#https://www.frontiersin.org/articles/10.3389/fpls.2020.00106/full

carb01 <- carbon_storage |>
  dplyr::select(-source_date, -id) |>
  dplyr::left_join(ecosystem_services |> sf::st_drop_geometry() |> dplyr::select(geographic, iso3, donor, total_area_m2), by = c("geographic" = "geographic")) |>
  na.omit() |>
  #dplyr::mutate(total_carbon_tonnes = round(value_float * total_area_m2 / (10^6), digits = 2)) |> # Calculate total carbon per area. 
  dplyr::mutate(
    total_carbon_tonnes = ifelse( # Calculate total carbon per area. 
      data_source != 3
      , round(value_float * total_area_m2 / (10^6), digits = 2) # In the case of DOPA data, the unit of measurement is t / km2.
      , round(value_float * total_area_m2 / (10^4), digits = 2) # In the case of soil grids, the unit of measurement is t / ha. 
    )
  ) |>
  dplyr::group_by(iso3, donor, data_source) |>
  dplyr::summarise(
    n = round(sum(total_carbon_tonnes / (10^6), na.rm = TRUE), digits = 2) # n is in mega tonnes.
  ) |>
  dplyr::mutate(
    Storage = dplyr::case_when(
      data_source == 3 ~ "Soil grids (ISRIC)"
      , data_source == 6 ~ "Above ground carbon"
      , data_source == 7 ~ "Below ground carbon"
      , data_source == 8 ~ "Carbon"
      , data_source == 47340 ~ "Soil grids"
      , TRUE ~ "other"
    )
  ) 


# carb02 <- carb01 |>
#   dplyr::ungroup() |>
#   dplyr::mutate(
#     test = factor(data_source, levels = c("3", "6", "7", "8"), labels = c("Soil grids", "Mean above ground carbon", "Mean below ground carbon", "Mean carbon"))
#   )


carbon_plots <- function(data, selection){
  
  cp_results <- list()
  
  carb_ly <- data |> 
    dplyr::ungroup() |>
    dplyr::filter(donor == selection) |>
    # dplyr::mutate(
    #   Storage = dplyr::case_when(
    #     data_source == 3 ~ "Soil grids"
    #     , data_source == 6 ~ "Mean above ground carbon"
    #     , data_source == 7 ~ "Mean below ground carbon"
    #     , data_source == 8 ~ "Mean carbon"
    #     , TRUE ~ "other"
    #   )
    # ) |>
    dplyr::rename(
      Country = iso3
    ) |>
    dplyr::select(Country, Storage, n) |>
    count_to_sunburst()
  
  carb_e <- data |>
    dplyr::ungroup() |>
    dplyr::filter(donor == selection) |>
    dplyr::group_by(Storage) |>
    #dplyr::mutate(iso3 = as.factor(iso3)) |>
    #tidyr::pivot_wider(names_from = Storage, values_from = n) |> #names_prefix = "source_",
    # dplyr::rename(
    #   `Soil grids` = source_3
    #   , `Mean above ground carbon` = source_6
    #   , `Mean below ground carbon` = source_7
    #   , `Mean carbon` = source_8
    # ) |>
    #dplyr::filter(iso3 == "BRA") |>
    #dplyr::group_by(iso3) |>
    echarts4r::e_charts(x = iso3) |>
    # echarts4r::e_bar(serie = `Soil grids`, stack = "grp") |>
    # echarts4r::e_bar(serie = `Mean above ground carbon`, stack = "grp") |>
    # echarts4r::e_bar(serie = `Mean below ground carbon`, stack = "grp") |>
    # echarts4r::e_bar(serie = `Mean carbon`, stack = "grp") |>
    echarts4r::e_bar(serie = n, stack = "grp") |>
    echarts4r::e_tooltip() |> 
    echarts4r::e_y_axis(
      splitLine = list(lineStyle = list(color = "#000000", width = 1, type = "dashed", interval = 0))
      , axisLine = list(show = TRUE, lineStyle = list(color = "#000000"))
    ) |>
    echarts4r::e_x_axis(
      # splitLine = list(lineStyle = list(color = "#000000", width = 1, type = "dashed", interval = 0))
        axisLine = list(show = TRUE, lineStyle = list(color = "#000000"))
      , axisLabel = list(interval = 0)
    ) |>
    echarts4r::e_datazoom() |>
    echarts4r::e_datazoom(yAxisIndex = 0) |>
    echarts4r::e_flip_coords()
  
  cp_results$carb_ly <- carb_ly
  cp_results$carb_e <- carb_e
  
  return(cp_results)
  
}

carb02 <- carb01 |>
  dplyr::filter(Storage != "Carbon") |>
  dplyr::filter(Storage != "Soil grids (ISRIC)")


carbon_kfw <- carbon_plots(data = carb02, selection = "KfW")
carbon_giz <- carbon_plots(data = carb02, selection = "GIZ")
carbon_kfw_giz <- carbon_plots(data = carb02, selection = "KfW/GIZ")

#carbon_kfw$carb_ly
#carbon_kfw$carb_e

# Data prep for time line plots. 

tl_tmp <- carbon_storage |>
  dplyr::select(-id, -source_date) |>
  dplyr::filter(data_source != 3) |>
  dplyr::filter(geographic %in% ecosystem_services$geographic) |>
  tidyr::pivot_wider(
    names_from = "data_source"
    , values_from = "value_float"
    , names_prefix = "ds_"
  )


tl_df <- ecosystem_services |>
  sf::st_drop_geometry() |>
  dplyr::left_join(tl_tmp, by = "geographic") |>
  dplyr::mutate(
    AGB_Mt = round(ds_6 * total_area_m2 / (10^6) / (10^6), digits = 2) # In metatonnes.
    , BGB_Mt = round(ds_7 * total_area_m2 / (10^6) / (10^6), digits = 2) # In metatonnes.
    , SG_Mt = round(ds_47340 * total_area_m2 / (10^6) / (10^6), digits = 2) # In metatonnes.
  ) |>
  dplyr::select(donor, start_date, end_date, AGB_Mt, BGB_Mt, SG_Mt)

tl_agb <- timeline_value(data = tl_df, value = "AGB_Mt", scale = 1)
tl_bgb <- timeline_value(data = tl_df, value = "BGB_Mt", scale = 1)
tl_sg <- timeline_value(data = tl_df, value = "SG_Mt", scale = 1)
tl_total <- tl_agb |>
  dplyr::left_join(tl_bgb, by = "year") |>
  dplyr::rename(
    AGB_Mt = wert.x
    , BGB_Mt = wert.y
  ) |>
  dplyr::left_join(tl_sg, by = "year") |>
  dplyr::rename(
    SG_Mt = wert
  )
tl_total$donor = c("total")

tl_agb <- timeline_value(data = tl_df, value = "AGB_Mt", scale = 1, donor = "KfW")
tl_bgb <- timeline_value(data = tl_df, value = "BGB_Mt", scale = 1, donor = "KfW")
tl_sg <- timeline_value(data = tl_df, value = "SG_Mt", scale = 1)
tl_kfw <- tl_agb |>
  dplyr::left_join(tl_bgb, by = "year") |>
  dplyr::rename(
    AGB_Mt = wert.x
    , BGB_Mt = wert.y
  ) |>
  dplyr::left_join(tl_sg, by = "year") |>
  dplyr::rename(
    SG_Mt = wert
  )
tl_kfw$donor <- c("KfW")


tl_agb <- timeline_value(data = tl_df, value = "AGB_Mt", scale = 1, donor = "GIZ")
tl_bgb <- timeline_value(data = tl_df, value = "BGB_Mt", scale = 1, donor = "GIZ")
tl_sg <- timeline_value(data = tl_df, value = "SG_Mt", scale = 1)
tl_giz <- tl_agb |>
  dplyr::left_join(tl_bgb, by = "year") |>
  dplyr::rename(
    AGB_Mt = wert.x
    , BGB_Mt = wert.y
  ) |>
  dplyr::left_join(tl_sg, by = "year") |>
  dplyr::rename(
    SG_Mt = wert
  )
tl_giz$donor <- c("GIZ")


tl_agb <- timeline_value(data = tl_df, value = "AGB_Mt", scale = 1, donor = "KfW/GIZ")
tl_bgb <- timeline_value(data = tl_df, value = "BGB_Mt", scale = 1, donor = "KfW/GIZ")
tl_sg <- timeline_value(data = tl_df, value = "SG_Mt", scale = 1)
tl_kfw_giz <- tl_agb |>
  dplyr::left_join(tl_bgb, by = "year") |>
  dplyr::rename(
    AGB_Mt = wert.x
    , BGB_Mt = wert.y
  ) |>
  dplyr::left_join(tl_sg, by = "year") |>
  dplyr::rename(
    SG_Mt = wert
  )
tl_kfw_giz$donor <- c("KfW/GIZ")

tl_data <- dplyr::bind_rows(
  tl_total
  , tl_kfw
  , tl_giz
  , tl_kfw_giz
  ) |>
  dplyr::mutate(year = as.factor(year))


```


#### KfW


```{r, figures-side, fig.show="hold", out.width="50%"}

#par(mar = c(4, 4, .1, .1))
carbon_kfw$carb_ly
carbon_kfw$carb_e


```


#### GIZ


```{r, fig.show="hold", out.width="100%"}

#par(mar = c(4, 4, .1, .1))
carbon_giz$carb_ly
carbon_giz$carb_e

```


#### KfW/GIZ


```{r, fig.show="hold", out.width="50%"}

#par(mar = c(4, 4, .1, .1))
carbon_kfw_giz$carb_ly
carbon_kfw_giz$carb_e

```


###

Ann.: Within the charts, $n$ is measured in megatonnes (covered by protected areas within the respective countries). 

***

On an aggregate level, KfW and GIZ protect the following amounts on stored carbon.

```{r}

carb_dt <- carb02 |>
  dplyr::ungroup() |> 
  #dplyr::filter(Storage != "Mean carbon") |>
  dplyr::group_by(donor, Storage) |>
  dplyr::summarise(total_amount = sum(n)) |>
  dplyr::rename(
    Donor = donor
    , Megatonnes = total_amount
  ) |>
  janitor::adorn_totals()

dtcarb <- DT::datatable(
  carb_dt 
  , height = "auto"
  , width = "auto"
  , extensions = c("Buttons") #"FixedColumns"
  , options = list(
      searchHighlight = TRUE
    , pageLength = nrow(carb_dt)
    #, fixedColumns = list(leftColumns = 2)
    , dom = 'Bfrtip'
    , buttons = c('csv', 'excel') 
    #, lengthMenu = list(c(10, 25, 50, -1), c("10 rows", "25 rows", "50 rows", "all"))
    #, dom = "t"
    #, columnDefs = list(list(className = "dt-right", targets = 3))
   )
 ) |>
  #DT::formatRound(digits = 2, columns = c(3:4))
  DT::formatStyle(
      0
    , target = "row"
    , fontWeight = DT::styleEqual(nrow(carb_dt), "bold")
  ) 

dtcarb


```

As we can see the protected areas network stores `r sum(carb02$n)` Megatons of carbon that, if released completely to the atmosphere, would generate emissions which correspond to `r round(sum(carb02$n) / (38000 * 0.27), digits = 1)` times the world emissions realized in 2021.^[REF - https\://edgar.jrc.ec.europa.eu/report_2022]

Ann.: The above numbers refer to all projects realised by the respective donors within the overall time frame. They do not refer to the carbon storage protected within a specific year. This issue is addressed by the graphs below. 


***

```{r}
plot_tl_total <- tl_data |>
  dplyr::filter(donor == "total") |>
  #dplyr::ungroup() |>
  #dplyr::group_by(donor) |>
  echarts4r::e_charts(x = year) |>
  echarts4r::e_line(serie = AGB_Mt) |>
  echarts4r::e_line(serie = BGB_Mt) |>
  echarts4r::e_line(serie = SG_Mt) |>
  echarts4r::e_title(subtext = "(all donors; in Megatonnes per year)") |>
  echarts4r::e_legend(bottom = 0, left = 0) |>
  echarts4r::e_group(group = "tl")

plot_tl_kfw <- tl_data |>
  dplyr::filter(donor == "KfW") |>
  #dplyr::ungroup() |>
  #dplyr::group_by(donor) |>
  echarts4r::e_charts(x = year) |>
  echarts4r::e_line(serie = AGB_Mt) |>
  echarts4r::e_line(serie = BGB_Mt) |>
  echarts4r::e_line(serie = SG_Mt) |>
  echarts4r::e_title(subtext = "(KfW; in Megatonnes per year)") |>
  echarts4r::e_legend(bottom = 0, left = 0, show = FALSE) |>
  echarts4r::e_group(group = "tl")

plot_tl_giz <- tl_data |>
  dplyr::filter(donor == "GIZ") |>
  #dplyr::ungroup() |>
  #dplyr::group_by(donor) |>
  echarts4r::e_charts(x = year) |>
  echarts4r::e_line(serie = AGB_Mt) |>
  echarts4r::e_line(serie = BGB_Mt) |>
  echarts4r::e_line(serie = SG_Mt) |>
  echarts4r::e_title(subtext = "(GIZ; in Megatonnes per year)") |>
  echarts4r::e_legend(bottom = 0, left = 0, show = FALSE) |>
  echarts4r::e_group(group = "tl")

plot_tl_kfw_giz <- tl_data |>
  dplyr::filter(donor == "KfW/GIZ") |>
  #dplyr::ungroup() |>
  #dplyr::group_by(donor) |>
  echarts4r::e_charts(x = year) |>
  echarts4r::e_line(serie = AGB_Mt) |>
  echarts4r::e_line(serie = BGB_Mt) |>
  echarts4r::e_line(serie = SG_Mt) |>
  echarts4r::e_title(subtext = "(KfW/GIZ; in Megatonnes per year)") |>
  echarts4r::e_legend(bottom = 0, left = 0, show = FALSE) |>
  echarts4r::e_group(group = "tl") |>
  echarts4r::e_connect_group(group = "tl")


plot_tl <- echarts4r::e_arrange(
  plot_tl_total
  , plot_tl_kfw
  , plot_tl_giz
  , plot_tl_kfw_giz
  , rows = 2
  , cols = 2
  , title = "Covered carbon storage"
)

plot_tl
```

***

While the above figures depict the overall carbon storage within a time line, it delivers no information about the capability of protected areas to store carbon in above or below ground biomass or soil grids. This gap is addressed by the map below. 


```{r, out.width = '100%'}
carb_tmp <- carbon_storage |>
  dplyr::select(-c(id, source_date)) |>
  dplyr::inner_join(ecosystem_services |> sf::st_drop_geometry() |> dplyr::select(geographic, total_area_m2), by = "geographic") |>
  dplyr::mutate(
    total_carbon_tonnes = ifelse( # Calculate total carbon per area.
      data_source != 3
      , round(value_float * total_area_m2 / (10^6), digits = 2) # In the case of DOPA data, the unit of measurement is t / km2.
      , round(value_float * total_area_m2 / (10^4), digits = 2) # In the case of soil grids, the unit of measurement is t / ha.
    )
  ) |>
  dplyr::mutate(
    total_carbon_mt = round(total_carbon_tonnes / (10^6), digits = 2)
  ) |>
  dplyr::select(-total_carbon_tonnes) |>
  dplyr::mutate(
    Storage = dplyr::case_when(
      data_source == 3 ~ "Soil grids (ISRIC)"
      , data_source == 6 ~ "Mean above ground carbon"
      , data_source == 7 ~ "Mean below ground carbon"
      , data_source == 8 ~ "Mean carbon"
      , data_source == 47340 ~ "Soil grids"
      , TRUE ~ "other"
    )
  ) |>
  #dplyr::select(-c(data_source, value_float, total_area_m2, total_carbon_tonnes)) |>
  dplyr::select(-c(data_source, total_area_m2)) |>
  dplyr::mutate(value_float = round(value_float, digits = 2)) |>
  tidyr::pivot_wider(
    names_from = Storage
    , values_from = c(value_float, total_carbon_mt) #total_carbon_mt
  )

carb_leaf <- ecosystem_services |> 
  #sf::st_drop_geometry() |>
  dplyr::select(-c(dplyr::contains(c("carbon", "species")))) |>
  dplyr::left_join(carb_tmp, by = c("geographic" = "geographic")) 

carb_leaf$label_agb <-
  with(carb_leaf, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "Donor: ", donor, "</br>"
    , "Mean above ground carbon (t/sq.km): ", `value_float_Mean above ground carbon`, "</br>"
    , "Total bove ground carbon (Mt): ", `total_carbon_mt_Mean above ground carbon`, "</br>"
    , "</p>", sep = "")
  )

carb_leaf$label_bgb <-
  with(carb_leaf, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "Donor: ", donor, "</br>"
    , "Mean below ground carbon (t/sq.km): ", `value_float_Mean below ground carbon`, "</br>"
    , "Total below ground carbon (Mt): ", `total_carbon_mt_Mean below ground carbon`, "</br>"
    , "</p>", sep = "")
  )

carb_leaf$label_sg <-
  with(carb_leaf, paste(
    "<p> <b>", "Metadata Origin: ", metadata_origin, "</b> </br>"
    #, "Primary Forests (", input$picker_base_year, "): ", round(base_area, digits = 0), " ha", "</br>"
    , "WDPAID: ", wdpa_id, "</br>"
    , "Donor: ", donor, "</br>"
    , "Mean soil grids (t/sq.km): ", `value_float_Soil grids`, "</br>"
    , "Total soil grids (Mt): ", `total_carbon_mt_Soil grids`, "</br>"
    , "</p>", sep = "")
  )


# Polygon data. 
#carb_polys <- forest_polys |>
#  dplyr::inner_join(carb_leaf |> sf::st_drop_geometry() |> dplyr::select(geographic, donor), by = c("id" = "geographic" ))

carb_polys <- carb_leaf 
sf::st_geometry(carb_polys) <- "geom_original"


carb_map <- create_empty_leaflet(overlays = c("Above ground", "Below ground", "Soil grids", "Polygons")) |>
  leaflet::addTiles() |>
  leaflet::addCircles(
    data = carb_leaf
    , color = ~pal_donor(donor)
    , group = "Above ground"
    #, popup = ~label_donor
    , radius = ~(`value_float_Mean above ground carbon` * 2)
    #, radius = runif(840, 1, 20000)
    #, stroke = FALSE
    , opacity = 1
    , popup = ~label_agb
  ) |>
  leaflet::addCircles(
    data = carb_leaf
    , color = ~pal_donor(donor)
    , group = "Below ground"
    #, popup = ~label_donor
    , radius = ~(`value_float_Mean below ground carbon` * 2)
    #, radius = runif(840, 1, 20000)
    #, stroke = FALSE
    , opacity = 1
    , popup = ~label_bgb
  ) |>
  leaflet::addCircles(
    data = carb_leaf
    , color = ~pal_donor(donor)
    , group = "Soil grids"
    #, popup = ~label_donor
    , radius = ~(`value_float_Soil grids` * 2)
    #, radius = runif(840, 1, 20000)
    #, stroke = FALSE
    , opacity = 1
    , popup = ~label_sg
  ) |>
  leaflet.extras::addFullscreenControl() |>
  leaflet::addLegend(
    "bottomright"
    , pal = pal_donor
    , values = unique(carb_leaf$donor)
    , title = "Donor"
    #, group = "Donor"
    , opacity = 1.0
  ) |>
  leaflet::addPolygons(
      data = carb_polys[1:833,] # Bec. some polygons make trouble, I can't plot all of them.
    , color = ~pal_donor(donor)
    , opacity = 0.9
    , group = "Polygons"
    #, label = ~htmltools::htmlEscape(project_name)
    , weight = 1
  ) 

carb_map

```

Using the *Mean above ground*, *Mean below ground* and *Mean Soil grids* checkboxes, the user can compare different sites by their capability to store carbon within the listed indicators which is reflected by the radius of the respective circles. That circles are connected with the checkboxes within the control panel. The larger a circle is, the higher is the value of the related indicator. It is obvious that the protected areas substantially differ in their capabilities of carbon storage. 


***

### Habitat and Species

PAs supported through KfW cover the habitat of several species that are threatened with extinction according to the *IUCN Red List of Threatened Species*. 


```{r}

hab01 <- habitat_species |>
  dplyr::mutate(
    species = dplyr::case_when(
      data_source == 14 ~ "Amphibia"
      , data_source == 9 ~ "Anthozoa"
      , data_source == 15 ~ "Aves"
      , data_source == 13 ~ "Chondrichthyes"
      , data_source == 12 ~ "Hydrozoa"
      , data_source == 11 ~ "Mammalia"
      , TRUE ~ "others"
    )
  ) |>
  dplyr::select(-id, -data_source, -source_date) |>
  dplyr::left_join(ecosystem_services |> sf::st_drop_geometry() |> dplyr::select(geographic, donor, iso3), by = c("geographic" = "geographic")) |>
  na.omit()


hab_e <- hab01 |>
  dplyr::filter(variable %in% c("critically_endangered", "endangered", "near_threatened", "threatened", "vulnerable")) |>
  dplyr::group_by(species, variable) |>
  dplyr::summarise(summe = sum(value)) |>
  dplyr::ungroup() |>
  dplyr::group_by(variable) |>
  echarts4r::e_chart(x = species) |>
  echarts4r::e_bar(serie = summe, stack = "grp") |>
  echarts4r::e_tooltip(trigger = "axis") |>
  echarts4r::e_x_axis(
      # splitLine = list(lineStyle = list(color = "#000000", width = 1, type = "dashed", interval = 0))
       # axisLine = list(show = TRUE, lineStyle = list(color = "#000000"))
      #, 
      axisLabel = list(interval = 0)
    ) |>
  echarts4r::e_theme("dark-digerati")

hab_e
```

